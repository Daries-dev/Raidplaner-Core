<?php

namespace rp\data\event;

use rp\system\event\IEventController;
use rp\system\event\RaidEventController;
use wcf\data\DatabaseObject;
use wcf\data\IMessage;
use wcf\data\ITitledLinkObject;
use wcf\data\object\type\ObjectTypeCache;
use wcf\data\TUserContent;
use wcf\data\user\UserProfile;
use wcf\system\html\output\HtmlOutputProcessor;
use wcf\system\request\IRouteController;
use wcf\system\request\LinkHandler;
use wcf\system\WCF;
use wcf\util\DateUtil;
use wcf\util\StringUtil;

/**
 * Represents a event.
 * 
 * @author  Marco Daries
 * @copyright   2023-2024 Daries.dev
 * @license Raidplaner is licensed under Creative Commons Attribution-ShareAlike 4.0 International 
 * 
 * @property-read   int $eventID        unique id of the event
 * @property-read   int $objectTypeID       id of the event controller object type
 * @property-read   string|null $title      name of the event
 * @property-read   int|null    $userID id of the user who created the event or `null` if the user does not exist anymore
 * @property-read   string  $username       name of the user who created the event
 * @property-read   int $created        timestamp at which the event has been created
 * @property-read   int $startTime      timestamp for start the event
 * @property-read   int $endTime        timestamp for end the event
 * @property-read   int $isFullDay      is `1` if the event occurs all day long, otherwise `0`
 * @property-read   string  $notes      notes of the event
 * @property-read   int $hasEmbeddedObjects     is `1` if there are embedded objects in the event, otherwise `0`
 * @property-read   int $views      number of times the event has been viewed
 * @property-read   int $enableComments     is `1` if comments are enabled for the event, otherwise `0`
 * @property-read   int $comments       number of comments on the event
 * @property-read   int $cumulativeLikes        cumulative result of likes (counting `+1`) and dislikes (counting `-1`) for the event
 * @property-read   array   $additionalData     array with additional data of the event
 * @property-read	int $deleteTime     timestamp at which the event has been deleted
 * @property-read	int $isDeleted      is `1` if the event is in trash bin, otherwise `0`
 * @property-read   int $isCanceled     is `1` if the even is canceled, otherwise `0`
 * @property-read   int $isDisabled     is `1` if the even is disabled, otherwise `0`
 */
final class Event extends DatabaseObject implements ITitledLinkObject, IRouteController, IMessage
{
    use TUserContent;

    /**
     * event controller
     */
    protected ?IEventController $controller = null;

    /**
     * end time object
     */
    private \DateTime $endTimeObj;

    /**
     * start time object
     */
    private \DateTime $startTimeObj;

    public function __construct($id, ?array $row = null, ?self $object = null)
    {
        parent::__construct($id, $row, $object);

        $this->startTimeObj = new \DateTime('@' . $this->startTime);
        $this->startTimeObj->setTimezone(WCF::getUser()->getTimeZone());

        $this->endTimeObj = new \DateTime('@' . $this->endTime);
        $this->endTimeObj->setTimezone(WCF::getUser()->getTimeZone());
    }

    /**
     * Returns true if the current user can edit these event.
     */
    public function canEdit(): bool
    {
        // check mod permissions
        if (WCF::getSession()->getPermission('mod.rp.canEditEvent')) {
            return true;
        }

        if ($this->isRaidEvent()) {
            if ($this->getController()->isLeader()) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns true if the given user has access to this event. If the given $user is null,
     * the function uses the current user.
     */
    public function canRead(?UserProfile $user = null): bool
    {
        if ($user === null) {
            $user = new UserProfile(WCF::getUser());
        }

        if ($this->isDeleted) {
            if (!$user->getPermission('mod.rp.canViewDeletedEvent')) {
                return false;
            }
        }

        if ($this->isDisabled) {
            if (!$user->getPermission('mod.rp.canModerateEvent')) {
                return false;
            }
        }

        if (!$user->getPermission('user.rp.canReadEvent')) {
            return false;
        }

        return true;
    }

    /**
     * Returns the event controller.
     */
    public function getController(): IEventController
    {
        if ($this->controller === null) {
            $className = ObjectTypeCache::getInstance()->getObjectType($this->objectTypeID)->className;

            $this->controller = new $className();
            $this->controller->setEvent($this);
        }

        return $this->controller;
    }

    /**
     * @inheritDoc
     */
    public function getExcerpt($maxLength = 255): string
    {
        return StringUtil::truncateHTML($this->getSimplifiedFormattedNotes(), $maxLength);
    }

    /**
     * Returns the formatted end time of the event.
     */
    public function getFormattedEndTime(bool $short = false): string
    {
        $language = WCF::getLanguage();
        $format = $language->get(DateUtil::TIME_FORMAT);

        if (!$short && !$this->isSelfDay()) {
            $format = $language->get(DateUtil::DATE_FORMAT) . ' ' . $format;
        }

        return DateUtil::format($this->endTimeObj, $format);
    }

    /**
     * @inheritDoc
     */
    public function getFormattedMessage(): string
    {
        $processor = new HtmlOutputProcessor();
        $processor->enableUgc = false;
        $processor->process($this->notes, 'dev.daries.rp.event.notes', $this->eventID, false);

        return $processor->getHtml();
    }

    /**
     * Returns the formatted start time of the event.
     */
    public function getFormattedStartTime(bool $short = false): string
    {
        $language = WCF::getLanguage();
        $format = $language->get(DateUtil::TIME_FORMAT);

        if (!$short && !$this->isSelfDay()) {
            $format = $language->get(DateUtil::DATE_FORMAT) . ' ' . $format;
        }

        return DateUtil::format($this->startTimeObj, $format);
    }

    /**
     * Returns the html code to display the icon.
     */
    public function getIcon(int $size = 16): string
    {
        return $this->getController()->getIcon($size);
    }

    /**
     * @inheritDoc
     */
    public function getLink(): string
    {
        return LinkHandler::getInstance()->getLink('Event', [
            'application' => 'rp',
            'object' => $this,
            'forceFrontend' => true
        ]);
    }

    /**
     * @inheritDoc
     */
    public function getMessage(): string
    {
        return $this->notes;
    }

    /**
     * Returns a simplified version of the formatted notes.
     */
    public function getSimplifiedFormattedNotes(): string
    {
        $processor = new HtmlOutputProcessor();
        $processor->setOutputType('text/simplified-html');
        $processor->process($this->notes, 'dev.daries.rp.event.notes', $this->eventID);

        return $processor->getHtml();
    }

    /**
     * @inheritDoc
     */
    public function getTime(): int
    {
        return $this->created;
    }

    /**
     * @inheritDoc
     */
    public function getTitle(): string
    {
        return $this->getController()->getTitle();
    }

    /**
     * @inheritDoc
     */
    protected function handleData($data): void
    {
        parent::handleData($data);

        // unserialize additional data
        $this->data['additionalData'] = (empty($data['additionalData']) ? [] : @\unserialize($data['additionalData']));
    }

    protected function isSelfDay(): bool
    {
        return $this->startTimeObj->format('Y-m-d') === $this->endTimeObj->format('Y-m-d');
    }

    /**
     * Returns `true` if this event is a raid event, otherwise `false`.
     */
    public function isRaidEvent(): bool
    {
        if ($this->getController() instanceof RaidEventController) return true;
        return false;
    }

    /**
     * @inheritDoc
     */
    public function isVisible(): bool
    {
        return $this->canRead();
    }

    /**
     * @inheritDoc
     */
    public function __get($name): mixed
    {
        $value = parent::__get($name);

        // treat additional data as data variables if it is an array
        $value ??= $this->data['additionalData'][$name] ?? null;

        return $value;
    }

    /**
     * @inheritDoc
     */
    public function __toString(): string
    {
        return $this->getFormattedMessage();
    }
}
